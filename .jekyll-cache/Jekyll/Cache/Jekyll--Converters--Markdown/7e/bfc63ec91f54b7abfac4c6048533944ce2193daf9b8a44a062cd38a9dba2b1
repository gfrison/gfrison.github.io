I"‡%<center><a href="https://www.flickr.com/photos/abbiateci64/32615368572"><img title="Umberto Boccioni - Rissa in Galleria(1910) by Maurizio Abbiateci (CCBY2)" src="http://localhost:4000/assets/rissa-galleria.jpg" /></a></center>

<p>The term <em>dynamic programming</em> has a curious origin.
When Richard Bellman late in the 1940s were seeking for a viral definition of his method, his boss was apparently not very inclined on science and in particular on mathematical research, the activities that Bellman was deep into when he formulate his famous <a href="https://en.wikipedia.org/wiki/Bellman_equation">equation</a>.
Likewise in marketing campaigns, where names and terms are carefully selected for attention teasing, Bellman coined the definition that combines the multi-staging and time-varying of <em>â€˜dynamicâ€™</em> with the optimization archetyping of <em>â€˜programmingâ€™</em>, coincidentally induced by the fame of Dantzigâ€™s <em>linear programming</em> for mathematical optimization.</p>

<p><em>DP</em> describes problems that involve dynamic processes for finding the best decision one after another. The backbone idea rolls around the splitting of a problem till its atomic parts are identified, then trimming those parts with a objective function. Basically, the core concept of <em>recursion</em>. Considering for example the Fibonacci algorithm:</p>

<center><img title="Fibonacci" src="http://localhost:4000/assets/fib-tree.png" /></center>

<p>The node <code class="highlighter-rouge">fib(2)</code> appear twice in the tree, therefore Fibonacci unveils an <em>overlapping</em> structure. It is eligible to be an <em>DP</em> algorithm. Not all recursive algorithms are inherently overlapping, look at <em>binary tree search</em>, <em>merge</em> and <em>quick sort</em>, for example. They donâ€™t manifest the property of traversing smaller chunk of data more then once, hence they cannot join Dynamic Programmingâ€™s family. When the sub-problems are repeated in the problem as whole, and their values are evaluated all over again unless a caching mechanism (<em>memoization</em>) could be displaced for preventing such inefficiency.</p>

<p>Bellman also conceived the <em>principle of optimality</em> according to which an optimal policy should always hands out the optimal decision from any state or action previously done. However the chessboard piecesâ€™ are laid, or however pedestrian are crossing the road or waiting on the platform, the agent will move pieces properly in case of chess and it will skirt traversing people in case of self-driving car. The automatic actor will always follow the best strategy from the first step and thereafter.
This is for introducing another property of <em>DP</em> methods, which is the <em>optimal structure</em>.</p>

<center><img title="shortest path problem" src="http://localhost:4000/assets/shortest-path.png" /></center>

<p>When a courier has to deliver a packet from <script type="math/tex">A</script> to the destination <script type="math/tex">F</script>, he will catch the shortest way highlighted in blue. The optimal decision for completing the journey <script type="math/tex">A \rightarrow F</script>, in the shortest path problem, includes necessarily the optimal solution <script type="math/tex">C \rightarrow F</script>. As you may have noticed, The recursion sweats also out of this property where nested sub-problems are always optimal on their way to the final target. The shortest path problem present the <em>optimal sub-structure</em>, which claims that an optimal solution of a problem includes necessarily the optimal solutions of its sub-problems. Not all recursive problems are optimal even in their encapsulated structure, and the counterfactual is given by slightly different dilemma, the longest path problem. The longest way <script type="math/tex">A \rightarrow F</script> includes the node <script type="math/tex">C</script>, but if we choose to start from <script type="math/tex">C</script>, the path is not included in the way starting from <script type="math/tex">A</script>.</p>

<h2 id="dynamic-programming-in-reinforcement-learning">Dynamic programming in reinforcement learning</h2>
<p>The first time <em>DP</em> and <em>RL</em> were mentioned together was by Minsky in the 1961 and it took form of the Bellman equation, because <em>RL</em> problems have expose usually an overlapping and optimal structure, ideal for being solved by <em>DP</em>.</p>
<h3 id="markov-decision-process">Markov decision process</h3>
<p><a href="/2018/12/26/first-steps-reiforcement-learning/">Reinforcement learning</a> is a class of methods for determining the optimal policy an agent should apply for maximize its return in a given environment. The entities with a role in <em>RL</em> are the state <script type="math/tex">S</script>, the mutable conditions an agent experience in an environment, the action <script type="math/tex">A</script> the agent execute in a particular state, and the reward <script type="math/tex">R</script>, if any, which score the goodness of action taken in a state. These are the pillars of the <a href="https://en.wikipedia.org/wiki/Markov_decision_process">markov decision process</a>, the framework that formalizes the policy <script type="math/tex">Ï€</script> as a sequence of steps <script type="math/tex">(S_t, A_t, R_t)</script>, aggregated in episodes.</p>

<center><img title="MDP" src="http://localhost:4000/assets/mdp-states.png" /></center>

<p>The <em>policy</em> is a mapping from states and related actions, <em>RL</em> tells us how the agentâ€™s policy changes as result of the experience.
For finding good policies, we need to estimate how good it is, in terms of future rewards, to be in a particular state.  Value functions <script type="math/tex">v_\pi(s)</script> define the expected return when starting from a given state <script type="math/tex">s</script> and following <script type="math/tex">\pi</script> thereafter. their fundamental property is that they satisfy recursive relationships similar to what we already have seen for dynamic programming. Hence, the idea of <em>DP</em> in <em>RL</em> is the use of value functions to organize the search for good policies.</p>

<h3 id="the-gridworld-example">The Gridworld example</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="http://localhost:4000/assets/gridworld.png" alt="GridWorld" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><em>Problem: Find all trajectories towards the flags from any cell</em></td>
    </tr>
  </tbody>
</table>

<p>Among many examples I may show for explaining what does <em>DP</em> stands for, this very simple <em>GridWorld</em> conveys the idea of an agent displaced in an 2D environment. The reward drives the agent to move toward the flagged corners regardless the position where the agent is located.
How the agent could learn the optimal ways? I give you an hint, letâ€™s start from the end, the flagged boxes.
In that position you donâ€™t have anymore rewards to gather, the task is brilliantly completed, so we assume the terminalâ€™s state value is is equal to <em>zero</em>.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="http://localhost:4000/assets/mdp-t1.png" alt="GridWorld" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><em>Iteration 1. Terminal state value is zero</em></td>
    </tr>
  </tbody>
</table>

<p>From end position, step back and look around. Among the actions you can do, the move that catapult you into the terminal state is more rewarding than others (<em>zero</em> instead of <em>-1</em>).
Congratulations! You already have solved a piece of the puzzle. It is just the last action, you still have to solve the rest of the grid. In that position, as in any other cell of the grid, you need to assign a value to the cell where you are in that particular moment, in order to pave the way to the final goal. That value <script type="math/tex">Q</script> indicates how good it is to be there. Not all cells carry the same value, some are more valuable than others. The agent, when choosing the next move, will move to the cell with highest value, among the surroundings. The value would not be just the reward you get in there (<em>-1</em>), but the reward plus the average of the values of the cells proximate to you.
<script type="math/tex">Q_t = r_t + \sum_{n=t+1}{Q_n}</script></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"><img src="http://localhost:4000/assets/mdp-t2.png" alt="GridWorld" /></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center"><em>Iteration 2: set the terminal state value to _zero_</em></td>
    </tr>
  </tbody>
</table>

<p>Going backward till the initial position, you see all rewards on the way to the terminal state waiting for you to being picked up. This is the value of your state.
You are in the middle of the trajectory towards the end, and the value of your state is equal of the reward in that state plus the sum of the discounted rewards thereafter.
Clearly, the agent moves toward the most promising among the surrounding cells, once it has realized their value.  Letâ€™s keep going.
The grid starts to unveil the optimal trajectories by just going backward and evaluating what could be the best move, taking the cell with highest value.
A pattern is identifiable, something that programmers knows well, the <em>recursion</em>, and simplified as:</p>

<script type="math/tex; mode=display">Q_t=r_t+argmax(Q_{t+1})</script>
:ET