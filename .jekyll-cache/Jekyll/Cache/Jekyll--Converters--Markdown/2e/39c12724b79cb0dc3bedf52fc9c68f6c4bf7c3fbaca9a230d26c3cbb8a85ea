I"²<p><img src="http://localhost:4000/assets/chain-failure-effect.jpg" alt="" />
I came back to Milano little time ago and Iâ€™ve bumped into an API implementation in this new job. This will be a library that aims to interact with a remote application through a simple text-based protocol.
The typical process is a sequence of authorization â€“ session initialization â€“ commands processing â€“ session disposing each of which enclosed in atomic request/respose interaction. The simplest and most immediate approach provides to write the protocol stubs, and manage them through simple methods that elaborate such commands at low level handling tcp sockets and the client/server handshaking with synchronous calls.
Sometimes the simplest is the best way, but not this time, especially within multi layer structured systems, where every component depends on many others, and any of those can fail.
This task rings as an alarm bell to me due to a recent project that looked like this one, and I can still remember the effects of hangs and missed responses in a SOA context; fortunately the event happened during a load test:</p>
<blockquote>
  <p>The application was a client interacting with openfire through XMPP. The investigation <a href="http://www.igniterealtime.org/community/thread/30088?tstart=0">uncovered a bug</a> that caused a dead lock in a connection pool in certain conditions, the consequences were easily predictable as the fast resource exhaustion, causing soon an application break down. The application server was over but also the client side was unrecoverable since the unresilient applicationâ€™s architecture didnâ€™t foresee hang requests.</p>
</blockquote>

<p>What is unacceptable is the chain of failures that a problem like this can disseminate along the process path, what about combined systems where one side does not expect the other side to hang off if it stops responding?
Domino is a pleasant show, you watch all pieces tracing doodles during their falls, itâ€™s funny but only when it doesnâ€™t look like your system when it works.</p>

<h2 id="dont-play-domino-be-skeptical-and-use-concurrent-package">Donâ€™t play domino, be skeptical (and use concurrent package)</h2>
<p>Blocking threads may happen every time you attempt to get resources out of a connection pool, deal with caches or registred objects, or make calls to external systems as this unfortunate experience above. I mean to be distrustful of each component you inquiry decoupling systems as necessary as to skirt the failure propagation. If your component is properly protected from its neighbours the probability of failure clearly drops down .
What does this mean in practice?
If youâ€™re dealing with sockets youâ€™re unaware of peer status, except when you send or receive bytes, then check the connectivity polling with fake sends and using <a href="http://java.sun.com/javase/6/docs/api/java/net/Socket.html#setSoTimeout(int)">setSoTimeout(int timeout)</a> to prevent blocking reads.
However, I find much more effective isolating the whole business unit in a single timeboxed job, because delays may also come from huge responses as unbounded result set or file fecthing.
If you allow the clients to set timeouts, the request thread quit the operation when the call is not completed in time. Easy?
Concurrent programming is hard and it requires high skills and it is even discoraged unless you donâ€™t want to reinvent the wheel. The <a href="http://java.sun.com/javase/6/docs/api/java/util/concurrent/package-summary.html">java.util.concurrent</a> package helps to craft your code with timeout controls as in the following example where Iâ€™m encapsulating a job unit (a login) into an <a href="http://java.sun.com/javase/6/docs/api/java/util/concurrent/ExecutorService.html">ExecutorService</a>.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Login</span> <span class="kd">implements</span> <span class="nc">Callable</span> <span class="o">{</span></code></pre></figure>

<p>The Login action implements the <a href="http://java.sun.com/javase/6/docs/api/java/util/concurrent/Callable.html">Callable</a> interface; despite Runnable it may throw checked exceptions when executed.</p>

<figure class="highlight"><pre><code class="language-java" data-lang="java"><span class="nc">Login</span> <span class="n">login</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Login</span><span class="o">(</span><span class="n">user</span><span class="o">,</span> <span class="n">password</span><span class="o">);</span>
<span class="nc">Future</span><span class="o">&lt;?&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="n">exe</span><span class="o">.</span><span class="na">submit</span><span class="o">(</span><span class="n">login</span><span class="o">);</span>
<span class="k">try</span> <span class="o">{</span>
  <span class="n">res</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">commandTimeout</span><span class="o">,</span> <span class="nc">TimeUnit</span><span class="o">.</span><span class="na">MILLISECONDS</span><span class="o">);</span>
<span class="o">}</span>
<span class="k">catch</span> <span class="o">(</span><span class="nc">ExecutionException</span> <span class="n">e</span><span class="o">)</span> <span class="o">{</span>
  <span class="n">log</span><span class="o">.</span><span class="na">error</span><span class="o">(</span><span class="s">"error on login"</span><span class="o">,</span> <span class="n">e</span><span class="o">);</span>
<span class="o">}</span>
<span class="k">finally</span> <span class="o">{</span>
  <span class="n">res</span><span class="o">.</span><span class="na">cancel</span><span class="o">(</span><span class="kc">true</span><span class="o">);</span>
<span class="o">}</span></code></pre></figure>

<p>The tip shows to launch the callable through <a href="http://java.sun.com/javase/6/docs/api/java/util/concurrent/ScheduledThreadPoolExecutor.html#submit(java.util.concurrent.Callable)">ScheduledThreadPoolExecutor.submit</a> and waiting the taskâ€™s end through <a href="http://java.sun.com/javase/6/docs/api/java/util/concurrent/Future.html#get(long,%20java.util.concurrent.TimeUnit)">Future.get(long timeout, TimeUnit timeUnit)</a>. By specifying the timeout value the operation will be completed in time , otherwise a TimeoutException will be thrown.</p>

<p><em>N.B.</em>: in this last case when timeout occours the ExecutorService doesnâ€™t seem to take care about the still open thread, so donâ€™t forget to execute <a href="http://java.sun.com/javase/6/docs/api/java/util/concurrent/Future.html#cancel(boolean)">Future.cancel(true)</a> in the final statement.</p>
:ET